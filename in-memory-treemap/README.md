# Домашнее задание к занятию 4.6. InMemory-хранение данных - коллекция TreeMap

Необходимо выполнить и предоставить на проверку следующие задачи:

## Задача № 1

Совсем недавно мы с вами создавали программу для хранения номеров телефонов, слеудующая программа будет
будет немного схожа по тематике. Нужно написать программу для хранения пропушенных звонков, используя
уже изученные коллекции в том числе, коллекцию `TreeMap`. Программа должна хранить список пропущенных вызовов в формате:
`дата и время` звонка и конечно `имя контакта`.

Функциональные требования к программе:
* Добавление контакта (имя, фамилия, номер телефона, группа контакта: работа, друзья, семья).
* Удаление контакт по имени и фамилии.
* Добавление пропущенного вызова.
* Вывод всех пропущенных вызовов с указанием фамилии и имени, если контакта нет в списке контактов, вывести только номер телефона.
* Очистка пропущенных вызовов.
* Завершить работу программы (выход).

После запуска программа должна предложить пользователю выполнить любое действие из списка выше,
после завершения действия (например, ввода данных нового контакта), снова вывести список доступных действий (меню).

### Реализация

1. Создадим класс-файл `Contact.java` со следующими полями:
* Name (Имя - String)
* Surname (Фамилия - String)
* Phone (Номер телефона - String)
* Group (Группа - Enum)

Переопредлить метод `toString` для этого класса в удобочитаемый вид.

2. Создадим класс-перечисление `Group.java` (enum):
* WORK("Работа")
* FRIENDS("Друзья")
* FAMILY("Семья")

3. Для хранения контактов предлагаю использовать `HashMap`, в качестве ключа использовать номер телефона,
а в качестве значения хранить контактные данные. Лушче вынести эту коллекцию в отдельный класс `Contacts.java`,
где добавить методы для работы с этой коллекцией.

```
Map<String, Contact> contacts = new HashMap<>();
```

Нужно реализовать следующие `public` методы:
* Добавление контакта (имя, фамилия, номер телефона, группа контакта: работа, друзья, семья).
* Удаление контакт по имени и фамилии.
* Поиск контакт по номеру
* Переопределить метод toString в удобочитаемый вид.

4. Для хранения пропущенных вызовов использовать `TreeMap`, где ключ - `время пропущенного вызова`,
а значение - `номер телефона`. Для хранения времени звонка подойдет тип данных `LocalDateTime` - у него уже
определен метод `compareTo` для использования в коллекции `TreeMap`. Нужно так же создать отдельный класс для
хранения и работы с этой коллекцией `MissedCalls.java`.

```
Map<String, String> missedCalls = new TreeMap<>();
```

Нужно реализовать следующие `public` методы:
* Добавление пропущенного вызова.
* Возвращение списка пропущенных вызовов.
* Очистка списка пропущенных вызовов.

5. Создать класс `Main.java` в котором, после запуска программы предоставить пользователю выбор следующих методов:
* Добавление контакта (имя, фамилия, номер телефона, группа контакта: работа, друзья, семья).
* Удаление контакт по имени и фамилии.
* Добавление пропущенного вызова.
* Вывод всех пропущенных вызовов с указанием фамилии и имени, если контакта нет в списке контактов, вывести только номер телефона.
* Очистка пропущенных вызовов.
* Завершить работу программы (выход).

Для этого нужно будет создать в классе `Main.java` объекты классов `Contacts.java` и `MissedCalls.java` и передавать
пользовательские вызовы в эти объекты.

## Задача 2

Неизвестный попытался произвести атаку на сервер интернет провайдера, но администратор вовремя спохватился и успел снять логи,
перед тем как отключить всю систему. В логах не так много ip-адресов, известно что злоумышленник делал больше всего запросов на сервер.
Нужно выяснить ip-адрес злоумышленника и как можно скорей, отыскать его данные в базе клиентов и отправить данные в полицию.

Что у нас есть?

[Лог файл сервера - server.log](./server.log)

[База клиентов - users.db](./users.db)

Функциональные требования к программе:
* Прочитать данные из файла `users.db`
* Прочитать данные из файла `server.log`
* Посчитать количество вхождений каждого ip-адреса в файл `server.log`
* Вывести `top-1` - самого часто встречаемого ip-адреса с количеством вхожений и владельцем. 

Нужно прочитать все данные из файла `server.log`, посчитать количество всех одинаковых ip-адресов,
а потом найти его в базе пользователей `users.db`.

Для чтение из файла можно использовать класс `Scanner`, пример чтения:
```
//Создание объекта файл
File file = new File("file.txt");

//Создаем scanner для чтения из файла
Scanner scanner = new Scanner(file);

//Построчно читаем файл в цикле, пока файл не закончится
while (scanner.hasNextLine()) {
    String line = scanner.nextLine() 
    System.out.println(line); //вывод данных из файла (пример)
}

//закрываем scanner после чтения, для освобождения файла и ресурсов
scanner.close();
```

### Реализация

1. Создать класс `User.java` с полями: id, фамилия, имя, отчество, адрес проживания.
  
2. Прочитать данные из файла [База клиентов - users.db](./users.db) в TreeMap, где ключ id пользователя,
а значение - объект типа User полями.

3. Дополнительно сохранить в отдельную коллекцию id пользователя и ip-адрес под которыми он выходи в интернет.
Можно сохранить адреса в `HashMap usersIps`, где ключ `id пользователя`, а значение множество `ip-адерсов` (Set<String>)

4. Прочитать второй файл `server.log`, как видно из лог-файла у нас множество адресов с портами, создадим второй
HashMap и в качестве ключа будем использовать ip-адрес, а в качестве значения количество сколько раз он встретился нам
в файле:
```
Map<String, Integer> logs = new HashMap<>();
while (scanner.hasNextLine()) {
    String ip = scanner.readLine();
    if (logs.get(ip) == null) {
        logs.put(ip, 1);
    } else {
        logs.put(ip, (logs.get(ip) + 1));
    }
}
```
Найдя максимальное число в этой HashMap, мы найдем злоумышленника.
Получив ip-адресс сохраним его в переменную `String villainIp = "xxx.xxx.xxx.xxx"`.

5. Найдем id пользователя с помощью `map usersIps`, перебрав в цикле всю map.
Сохраним id пользователя в переменную `String villainId`

6. Найдем и выведем на экран фамилию, имя, адрес пользователя и количество его входов.

7. Дело раскрыто.

## Задача 3

На этот раз мы поможем библиотекарю разобраться со всем каталогом книг который у него накопился за последнюю сотню лет.
Нужно каталогизировать все книги по жанрам. Задача довольна проста, библиотекарь вводит название книги, автора и жанр, книга попадает
в отдельный список (множество), если такого жанра еще нет, то он создается. 


=======

Все задачи обязательны к выполнению для получения зачета, кроме задач со `*`. Присылать на проверку можно каждую задачу по отдельности или все задачи вместе. Во время проверки по частям ваша домашняя работа будет со статусом "На доработке".

Любые вопросы по решению задач задавайте в группе на Facebook.

## Инструкция по выполнению домашнего задания

1. Код пишите в IDE (рекомендуется Intellij Idea), а на сайт только вставте для отправки!
    1. Почему IDE? Быстрота, подсветка ошибок, отладка по шагам.
    2. Почему Intellij Idea? Родитель Android Studio, бесплатная, умная, лучшая IDE во всей мультивселенной.
3. Опирайтесь на принятый [стиль оформления кода](https://github.com/netology-code/codestyle/blob/master/java/README.md).
4. Зарегистрируйтесь на сайте [Repl.IT](http://repl.it/).
5. Перейдите в раздел **my repls**.
6. Нажмите кнопку **Start coding now!**, если приступаете впервые, или **New Repl**, если у вас уже есть работы.
7. В списке языков выберите `Java`.
8. Убедитесь что на сайте всё работает также как и у вас на компьютере, нажав на кнопку **Run**. Результат появится в правой части окна.
9. После окончания работы нажмите кнопку **Share** и скопируйте ссылку из поля Share link.
10. В личном кабинете на сайте [netology.ru](http://netology.ru/) в поле комментария к домашней работе вставьте скопированную ссылку и отправьте работу на проверку.

*Никаких файлов прикреплять не нужно.*
