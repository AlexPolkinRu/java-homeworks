# Домашнее задание к занятию 4.6. InMemory-хранение данных - коллекция TreeMap

Необходимо выполнить и предоставить на проверку следующие задачи:

## Задача № 1

Наверное у каждого из нас есть списки желаемых покупок? Особенно, скорее всего, перед праздниками.
Так давайте напишем программу для хранения этих "хотелок", да так чтобы они автоматически сортировались по какому-то признаку.

Что известно:
* Сущность "Хотелка": название (уникальное), краткое описание, цена, URL адрес интернет магазина или адрес магазина, 
приоритет (0 - 5, где 0 - очень низкий приоритет, а 5 - очень высокий приоритет).

Из функциональных требований к программе реализуем:
* Добавление "хотелок";
* Сортировка по убыванию/возрастанию цены;
* Сортировка по приоритету от самого важного до самого низкого приоритета.

### Реализация

1. Создадим классы Wish. Рекомендую использовать следующие типы данных: 
* Название - String;
* Краткое описание - String;
* Цена - double;
* URL адрес интернет магазина или адрес магазина - String;
* Приоритет - int.

2. Для того чтобы мы могли изменять тип сортировки, в процессе выполнения программы будем использовать интерфейс Comparator, 
а не Comparable. Потому что, если мы будем имлементирвовать интерфейс Comparable на уровне сущности Wish, мы будем привязаны к какому-то типу сортировки, в тоже время мы можем просто передавать в конструктор TreeSet желаемый Comparator. 
Важно: в уже созданном объекте TreeSet нельзя менять тип сортировки. 

3. Поэтому необходимо создать 2 класса, имплементирующих интерфейс Comparator<Wish> (один для сортировки по цене, 
второй для сортировки по приоритету), в которых нужно передавать в конструкторе направление сортировки и переопределить метод compare, используя направление сортировки из конструктора. Направление сортировки можно задавать, используя `enum`.

4. В начале работы программы опросите пользователя, как нужно сортировать "хотелки". 

```java
System.out.println("1. Сортировка по убыванию цены");
System.out.println("2. Сортировка по возрастанию цены");
System.out.println("3. Сортировка по приоритету от самого важного");
System.out.println("4. Сортировка по приоритету от низкого приоритета");
System.out.println("Введите индентификатор сортировки:");
String id = scanner.nextLine();

 ```

5. Затем создаем объект TreeSet и передаем в конструктор выбранный компаратор.

6. По аналогии с предыдущими заданиями считываем сущности `Wish` с клавиатуры и добавляем в созданный объект TreeSet.
Для вывода объекта на экран переопределим метод `toString()`.

7. После ввода объектов выведем содержимое `TreeSet`, используя `iterator` или `forEach` цикл.

8. Для демонстрации работы программы создадим в коде при запуске программы несколько "хотелок" (> 10).

## Задача 1`*`

В дополнение к возможным действиям задачи № 1 добавьте возможность, чтобы после ввода всех "хотелок" и вывода в консоль всех "хотелок" в выбранной сортировке, программа предлагала и дальше отсортировать уже созданный список "хотелок", как в пункте 4. Это можно реализовать с помощью нового объекта TreeSet с выбранным Comparator и в него добавить содержимое старого TreeSet с помощью метода `addAll(Collection<? extends E> c)`.

## Задача 2

Задача по системе подбора кандидатов по базам резюме. 
Необходимо хранить кандидатов таким образом, чтобы они сортировались в порядке убывания, по двум полям одновременно - релевантности резюме и по оценке на собеседовании.

1. Вам нужно создать класс `Candidate`:
    * "Фамилия Имя Отчество" (через пробел) - String - уникальное значение;
    * Пол - String;
    * Возраст - String;
    * Релевантность резюме (соответствие резюме предлагаемой вакансии - relevance) - Integer (0-5 - где 0 - низкое значение соответствия, а 5 - очень высокое значение соответствия);
    * Оценка на собеседовании (rating) - Integer (0-5 - где 0 - низкое значение оценки, а 5 - очень высокое значение оценки).
    
Также для вывода кандидата на экран переопределить метод `toString`.

2. Необходимо хранить в TreeSet таким образом, чтобы они сортировались в порядке убывания, по двум атрибутам одновременно “relevance” и ”rating”.
Поэтому Вы можете воспользоваться либо Comparator, с переопределенным методом compare, в котором будут проводиться сравнения по двум полям `relevance` и `rating`.
Либо можно воспользоваться способом из Java 8 [Comparator.thenComparing()](https://howtodoinjava.com/sort/sort-on-multiple-fields/), который намного удобнее.
Пример ожидаемой сортировки:

```
ФИО, Релевантность резюме, Оценка на собеседовании
Иванов Иван Иванович, 4, 5 

Петров Иван Александрович, 4, 3 

Максимов Иван Александрович, 3, 5 

```
3. По аналогии с предыдущими заданиями считываем сущности `Candidate` с клавиатуры и добавляем в созданный объект TreeSet.

4. После ввода объектов выведем содержимое `TreeSet`, используя `iterator` или `forEach` цикл.

5. Для демонстрации работы программы создадим в коде при запуске программы несколько "кандидатов" (> 10), желательно несколько их них с одинаковым значением `relevance` для лучшего понимания.

=======

Все задачи обязательны к выполнению для получения зачета, кроме задач со `*`. Присылать на проверку можно каждую задачу по отдельности или все задачи вместе. Во время проверки по частям ваша домашняя работа будет со статусом "На доработке".

Любые вопросы по решению задач задавайте в группе на Facebook.

## Инструкция по выполнению домашнего задания

1. Код пишите в IDE (рекомендуется Intellij Idea), а на сайт только вставте для отправки!
    1. Почему IDE? Быстрота, подсветка ошибок, отладка по шагам.
    2. Почему Intellij Idea? Родитель Android Studio, бесплатная, умная, лучшая IDE во всей мультивселенной.
3. Опирайтесь на принятый [стиль оформления кода](https://github.com/netology-code/codestyle/blob/master/java/README.md).
4. Зарегистрируйтесь на сайте [Repl.IT](http://repl.it/).
5. Перейдите в раздел **my repls**.
6. Нажмите кнопку **Start coding now!**, если приступаете впервые, или **New Repl**, если у вас уже есть работы.
7. В списке языков выберите `Java`.
8. Убедитесь что на сайте всё работает также как и у вас на компьютере, нажав на кнопку **Run**. Результат появится в правой части окна.
9. После окончания работы нажмите кнопку **Share** и скопируйте ссылку из поля Share link.
10. В личном кабинете на сайте [netology.ru](http://netology.ru/) в поле комментария к домашней работе вставьте скопированную ссылку и отправьте работу на проверку.

*Никаких файлов прикреплять не нужно.*
