Домашнее задание по лекции 3.2. - Массивы многомерные
==
## Задача 1. Поворот матрицы

### Описание

В компьютерной графике очень широко используется прием поворота матрицы - например, для того,
чтобы очень быстро изменить цвет объекта в какую-либо сторону (например, сделать объект чуть краснее).

Научимся поворачивать матрицу с равными сторонами. Этот алгоритм широко используется в графических редакторах 
вроде Photoshop для поворота изображений.

Дано: двумерная матрица 8 на 8, из случайных чисел от 0 до 255 (спектр цветов RGB).
Напишите алгоритм "поворота" такой матрицы на 90 градусов по часовой стрелке.


### Реализация

1. И так у нас есть матрица с размерами 8x8, которую нужно повернуть на 90 градусов по часовой стрелке.
Для начало создадим матрицу (размерность матрицы сохраним в переменной filedSize).

```  
int filedSize = 8;
int [] colors = new int[filedSize][filedSize];
```  

2. Теперь заполним матрицу случайными значениями в диапазоне от 0 до 255:

```  
for (int i = 0; i< filedSize; i++) {
  for (int j = 0; j< filedSize; j++) {
  // для случайных значений воспользуемся готовым решением из библиотеки java.util.Random
    colors[i][j] = new Random().nextInt(254);
  }
}
```  

3. Выводим матрицу на экран:
```  
for (int i = 0; i< filedSize; i++) {
  for (int j = 0; j< filedSize; j++) {
    // Используем оператор print - без перехода на следующую строку
    // Добавляем пробел после вывода значения каждой ячейки.
    System.out.print(warField[i][j]+ " ");
  }
  // Переход на следующую строку
  System.out.println();
}
```  
4. Для развернутой матрицы создадим пустую матрицу той же размерности:
``` 
int [] rotatedColors = new int[filedSize][filedSize];
``` 
5. Новая матрица должна принять значения ячеек первой матрицы, но с поворотом на 90 градусов по часовой стрелке.
Это значит, что значение первой ячейки rotatedColors[0][0] (первая строка, первое значение) новой матрицы,
должна быть равна первому значению ячейки последней строки матрицы colors (colors[filedSize-1][0]).

6. Напишем некоторые равенство значений в ручную:

``` 
rotatedColors[0][0]  = colors[7][0];
rotatedColors[0][1]  = colors[6][0];
rotatedColors[0][2]  = colors[5][0];
rotatedColors[0][3]  = colors[4][0];
rotatedColors[0][4]  = colors[3][0];
rotatedColors[0][5]  = colors[2][0];
rotatedColors[0][6]  = colors[1][0];
rotatedColors[0][7]  = colors[0][0];
``` 

7. Исходя из выше сказанного нужно: 
* написать циклы, при помощи которых можно пробежаться по матрицам,
* каждому элементу новой матрицы rotatedColors присвоить соответствующее значение из имеющейся colors матрицы.

Перебор элементов матрицы можно организовать встроенными циклами, так же как вы вывели значения на экран colors матрицы.

8. Выводим перевернутую матрицу на экран:

``` 
for (int i = 0; i< filedSize; i++) {
  for (int j = 0; j< filedSize; j++) {
    // Используем оператор print - без перехода на следующую строку
    // Добавляем пробел после вывода значения каждой ячейки.
    System.out.print(rotatedColors[i][j]+ " ");
  }
  // Переход на следующую строку
  System.out.println();
}
``` 

### Пример

Дана следующая матрица:
```  
114 112 148 83 204 22 125 31
192 231 245 128 63 246 139 17
61 128 224 45 91 57 239 34
219 237 167 191 236 146 144 117
35 199 102 124 208 195 21 147
52 229 126 32 24 145 19 39
107 43 190 43 47 172 18 19
62 221 6 208 241 198 187 85
```  
Вывод:
```  
62 107 52 35 219 61 192 114
221 43 229 199 237 128 231 112
6 190 126 102 167 224 245 148
208 43 32 124 191 45 128 83
241 47 24 208 236 91 63 204
198 172 145 195 146 57 246 22
187 18 19 21 144 239 139 125
85 19 39 147 117 34 17 31
```  

## Задача 2. Морской бой

### Описание

Вы пишете игру “морской бой” в минимальном варианте, где стреляете только вы.
На вход-двумерный массив 10 на 10, заполненный числами.

Возможные числа 0 (“пустое поле”), 1 (“есть корабль”), 2 (“корабль застрелен”), 3 (“промах”).
При этом “корабли” занимают не более 10 клеток. Расстоянием между кораблями и “палубностью” кораблей мы пренебрегаем.
Пользователь вводит координаты поля, в которое стреляет. 

В зависимости от результата “выстрела” программа выдает ему ответ- “попал”/”не попал”.
После попадания во все корабли, либо по истечению 30 ходов, игра считается законченной.
Если за время игры были застрелены все 10 клеток с кораблями, то игра выиграна.

### Реализация

1. Для решения данной задачи нужно создать двумерный массив 10x10 с заполненными числами 0 и 1:
``` 
0 - "пустое поле"
1 - "есть корабль"
``` 
Создадим переменную filedSize, для сохранения размерности массива:
``` 
// определяем размерность массива
int filedSize = 10;
// Создаем двумерный массив
int warField[][]= new int[filedSize][filedSize];
``` 
Заполним нашу матрицу "пустыми полями" (число 0):
``` 
// Цикл по первой размерности (первые квадратные скобки)
for (int i = 0; i< filedSize; i++) {
  // Цикл по второй размерности (вторые квадратные скобки)
  for (int j = 0; j< filedSize; j++) {
    warField[i][j] = 0;
  }
}
``` 

Так же во время игры ячейки матрицы могут изменяться значениями:
``` 
2 - "корабль застрелен"
3 - "промах"
``` 

2. В условии задачи дано, что максимальное число кораблей 10.
Объявим переменную maxCount для хранения максимального числа кораблей.
``` 
int maxCount = 10;
``` 
Теперь когда у нас есть поле, разместим на нем корабли.

3. Разместим корабли в случайном порядке на поле (матрица warField):
Для этого нужны случайные значения в диапазоне от 0 до 9 для координат ячеек.

Обозначим значения первой размерности shipPlace1, а  второй размерности shipPlace2,
в таком случае у нас случайные координаты ячеек для кораблей примут следующий вид:
``` 
int shipPlace1 = new Random().nextInt(filedSize);
int shipPlace2 = new Random().nextInt(filedSize);
warField[shipPlace1][ shipPlace2] = 1;
``` 
Разместим все корабли на поле в случайном порядке используя цикл, обеспечив максимальное число кораблей 10:
``` 
for (int i = 0; i< maxCount; i++) {
  // для случайных значений воспользуемся готовым решением из библиотеки java.util.Random
  int shipPlace1 = new Random().nextInt(filedSize);
  int shipPlace2 = new Random().nextInt(filedSize);
  warField[shipPlace1][ shipPlace2] = 1;
}
``` 
Так как координаты могут повторяться внесем некоторые изменения в нашем цикле, 
добавив проверку наличия корабля в указанной ячейке, обеспечив при этом повторный круг для данного корабля.

``` 
for (int i = 0; i< maxCount; i++) {
  int shipPlace1 = new Random().nextInt(filedSize);
  int shipPlace2 = new Random().nextInt(filedSize);
  if (1 == warField[shipPlace1][ shipPlace2]){
    // повторный круг для данного корабля
    i --;
  }
  warField[shipPlace1][ shipPlace2] = 1;
}
``` 
4.И так у нас есть поле с кораблями, выводим его на экран:
``` 
// выводим массив на экран
// Цикл по первой размерности выводит строки
for (int i = 0; i< filedSize; i++) {
  // Цикл по второй размерности выводит колонки - вывод одной строки
  for (int j = 0; j< filedSize; j++) {
    // Используем оператор print - без перехода на следующую строку
    System.out.print(warField[i][j]);
  }
  // Переход на следующую строку
  System.out.println();
}
``` 
5. Надо вывести понятные пользователю приглашения на ввод требуемых данных.

6. Нужно создать переменные, в которых сохранятся координаты, вводимые пользователем.
Пускай для первой размерности будет переменная int place1 = 0; , для второй размерности int place2 = 0;.

7. Нужно привести введенное значение к числовому типу. `Integer.parseInt(inputString)`;

8. Зная координаты мы легко найдем нужное для нас значение в матрице.
В зависимости от значения в клетке, на экран выводится результат “попал”/”не попал”:
``` 
if (1 == warField[place1][place2]){
  warField[place1][place2] = 2
  System.out.print(“попал”);
}else {
  warField[place1][place2] = 3
  System.out.print(”не попал”);
}
``` 
9.Добавить проверку на ввод целостных чисел для координат при помощи `try{}catch{}`.
``` 
try {
  int place1 = Integer.parseInt(inputString);
} catch (NumberFormatException e) {
  System.out.println("Введите целостное число");
}
``` 
10. Создать переменную, которая будет хранить в себе количество ходов:
``` 
int steps = 0;
``` 
После каждого ввода координат во время проверки попадания по кораблю >> 
данная переменная должна увеличиться на единицу >> 
после чего если переменная достигла числа 30 >> 
программа выходит из цикла, на экран выводится количество попаданий игрока и "игра окончена".

11.Создать переменную, которая будет считывать количество правильных попаданий по кораблям:
``` 
int hit = 0;
``` 
После каждого попадания проверять количество, если число достигло 10 (максимальное количество кораблей), 
то игра должна прерваться (выход из цикла), и на экран выводится надпись " Вы победили ".
