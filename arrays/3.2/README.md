Домашнее задание по лекции 3.2. - Массивы многомерные
==
## Задача 1. Поворот матрицы на 90 градусов по часовой стрелке

### Описание

Научимся поворачивать матрицу с равными сторонами. Этот алгоритм мог бы быть использован в графических редакторах 
вроде Photoshop для поворота изображений.

Дано: двумерная матрица 8 на 8, из случайных чисел от 0 до 255 (спектр цветов GrayScale).
Напишите алгоритм "поворота" такой матрицы на 90 градусов по часовой стрелке.

### Реализация

1. И так у нас есть матрица с размерами 8x8, которую нужно повернуть на 90 градусов по часовой стрелке.
Для начало создадим матрицу (размерность матрицы сохраним в переменной filedSize).

```java
int SIZE = 8;
int[][] colors = new int[SIZE][SIZE];
```  

2. Теперь заполним матрицу случайными значениями в диапазоне от 0 до 255:

```java
Random random = new Random();
for (int i = 0; i< SIZE; i++) {
  for (int j = 0; j< SIZE; j++) {
  // для случайных значений воспользуемся готовым решением из библиотеки java.util.Random
    colors[i][j] = random.nextInt(256);
  }
}
```  

3. Выводим матрицу на экран:
```java
for (int i = 0; i< SIZE; i++) {
  for (int j = 0; j< SIZE; j++) {
    // %4d обозначает что мы под каждый номер резервируем 4 знака
    // (незантые будут заполнены пробелами)
    // таким образом у нас получиться ровная таблица
    System.out.format("%4d", colors[i][j]);
  }
  // Переход на следующую строку
  System.out.println();
}
```  
4. Для повернутой матрицы создадим пустой массив той же размерности:
```java
int[][] rotatedColors = new int[SIZE][SIZE];
``` 
5. Новая матрица должна принять значения ячеек первой матрицы, но с поворотом на 90 градусов по часовой стрелке.
Это значит, что значение первой ячейки rotatedColors[0][0] (первая строка, первое значение) новой матрицы,
должна быть равна первому значению ячейки последней строки матрицы colors (colors[SIZE-1][0]).

6. Исходя из выше сказанного нужно: 
* написать циклы, при помощи которых можно пробежаться по матрицам,
* каждому элементу новой матрицы rotatedColors присвоить соответствующее значение из имеющейся colors матрицы.

Перебор элементов матрицы можно организовать встроенными циклами, так же как вы вывели значения на экран colors матрицы.

### Пример

Дана следующая матрица:
``` 
114 112 148  83 204  22 125  31
192 231 245 128  63 246 139  17
 61 128 224  45  91  57 239  34
219 237 167 191 236 146 144 117
 35 199 102 124 208 195  21 147
 52 229 126  32  24 145  19  39
107  43 190  43  47 172  18  19
 62 221   6 208 241 198 187  85
```  
Вывод:
```  
 62 107  52  35 219  61 192 114
221  43 229 199 237 128 231 112
  6 190 126 102 167 224 245 148
208  43  32 124 191  45 128  83
241  47  24 208 236  91  63 204
198 172 145 195 146  57 246  22
187  18  19  21 144 239 139 125
 85  19  39 147 117  34  17  31
```  

## Задача 1*. Поворот матрицы на 90/180/270 градусов

### Описание

Добавьте в задачу \#1 возможность вводоить угол поворота (кратный 90) с клавиатуры.

## Задача 2. Морской бой

### Описание

Вы пишете игру “морской бой” в минимальном варианте, где стреляете только вы.
На вход-двумерный массив 10 на 10, заполненный числами.

Возможные числа 0 (“пустое поле”), 1 (“есть корабль”), 2 (“корабль застрелен”), 3 (“промах”).
При этом “корабли” занимают не более 10 клеток. Расстоянием между кораблями и “палубностью” кораблей мы пренебрегаем.
Пользователь вводит координаты поля, в которое стреляет. 

В зависимости от результата “выстрела” программа выдает ему ответ- “попал”/”не попал”.
После попадания во все корабли, либо по истечению 30 ходов, игра считается законченной.
Если за время игры были застрелены все 10 клеток с кораблями, то игра выиграна.

### Реализация

1. Для решения данной задачи нужно создать двумерный массив 10x10:
``` 
0 - "пустое поле"
1 - "есть корабль"
``` 
Создадим SIZE, для сохранения размерности массива:
```java
// определяем размерность массива
int SIZE = 10;
// Создаем двумерный массив
int warField[][]= new int[SIZE][SIZE];
``` 

Так же во время игры ячейки матрицы могут изменяться значениями:
``` 
2 - "корабль застрелен"
3 - "промах"
``` 

Для хранения состояние клетки создадим константы и дальше в коде будем использовать их:

```java
int EMPTY = 0;
int SHIP = 1;
int DEAD = 2;
int MISS = 3;
```

2. В условии задачи дано, что максимальное число кораблей 10.
Объявим переменную maxCount для хранения максимального числа кораблей.
```java
int MAX_COUNT = 10;
``` 
Теперь когда у нас есть поле, разместим на нем корабли.

3. Разместим корабли в случайном порядке на поле (матрица warField):
Для этого нужны случайные значения в диапазоне от 0 до 9 для координат ячеек.

Обозначим значения первой размерности shipPlace1, а  второй размерности shipPlace2,
в таком случае у нас случайные координаты ячеек для кораблей примут следующий вид:
```java
Random random = new Random();
for (int i = 0; i < MAX_COUNT; i++) {
  int shipPlace1 = random.nextInt(SIZE);
  int shipPlace2 = random.nextInt(SIZE);
  
  warField[shipPlace1][shipPlace2] = SHIP;
}
``` 

Так как координаты могут повторяться внесем некоторые изменения в нашем цикле, 
добавив проверку наличия корабля в указанной ячейке, обеспечив при этом повторный круг для данного корабля.

```java
Random random = new Random();
for (int i = 0; i< MAX_COUNT; i++) {
  int shipPlace1 = random.nextInt(SIZE);
  int shipPlace2 = random.nextInt(SIZE);
  
  if (warField[shipPlace1][shipPlace2] == SHIP){
    // повторная генерация положения для данного корабля
    i--;
  }
  
  warField[shipPlace1][shipPlace2] = SHIP;
}
``` 

4.И так у нас есть поле с кораблями, выводим его на экран:

```java 
// выводим массив на экран
// Цикл по первой размерности выводит строки
for (int i = 0; i< SIZE; i++) {
  // Цикл по второй размерности выводит колонки - вывод одной строки
  for (int j = 0; j< SIZE; j++) {
    // Используем оператор print - без перехода на следующую строку
    System.out.print(warField[i][j]);
  }
  // Переход на следующую строку
  System.out.println();
}
``` 

5. Далее необходимо ввести две координаты с клавиатуры с помощью `Scanner.nextInt()`. В зависимости от значения в матрице выводить соответсвующее сообщение.

6. После каждого хода выводить обновленную матрицу на экран, а так же проверять не превышенно ли максимальное количество шагов и остались ли ещё "не подбитые" корабли в игре.

## Инструкция по выполнению домашнего задания

1. Зарегистрируйтесь на сайте [Repl.IT](http://repl.it/).
2. Перейдите в раздел **my repls**.
3. Нажмите кнопку **Start coding now!**, если приступаете впервые, или **New Repl**, если у вас уже есть работы.
4. В списке языков выберите `Java`.
5. Код пишите в левой части окна, вместо строки `System.out.println("Hello world!");`.
6. Опирайтесь на принятый [стиль оформления кода](https://github.com/netology-code/codestyle/blob/master/java/README.md).
7. Посмотреть результат выполнения файла можно, нажав на кнопку **Run**. Результат появится в правой части окна.
8. После окончания работы нажмите кнопку **Share** и скопируйте ссылку из поля Share link.
9. В личном кабинете на сайте [netology.ru](http://netology.ru/) в поле комментария к домашней работе вставьте скопированную ссылку и отправьте работу на проверку.

*Никаких файлов прикреплять не нужно.*

Все задачи обязательны к выполнению для получения зачета. Присылать на проверку можно каждую задачу по отдельности или все задачи вместе. Во время проверки по частям ваша домашняя работа будет со статусом "На переработке".

Любые вопросы по решению задач задавайте в группе на Facebook.
