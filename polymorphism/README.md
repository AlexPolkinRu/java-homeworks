# Домашнее задание к занятию 2.3 Основы ООП: полиморфизм

Пока мы занимались нашим Task Manager'ом, в нём уже успело накопиться задачек по нескольким проектам от заказчиков.

## Коллекции элементов
Ниже в задачах мы будем использовать класс `List<>`, более подробный обзор которого будет в следующих лекциях. 
Назначение этого класса — хранить пронумерованный список объектов одного типа или его производных, указанного в угловых скобках (например `List<String> list` – объявление списка строк).
В первой задаче будет дан пример работы со списком. Его создания и наполнения элементами, определения количества элементов содержащихся в нём, а также получения конкретного элемента по его номеру.

> ВНИМАНИЕ
> Все программисты **считают начиная с нуля**! Первый элемент списка можно получить с помощью `list.get(0)`, второй `list.get(1)` соответственно.
> Когда программисты играют со своими детьми в прятки они говорят: "ноль, один, два, три, четыре, я иду искать!".
> Произошло так по историческим причинам, которые мы расмотрим при изучении темы массивы.

## Задача № 1

Один из проектов это игра-шутер (~~Half-Life 3, только никому ни слова~~). У игрока должна быть возможность использовать разные виды оружия, в будущем в игру могут быть добавлены новые. Необходимо спроектировать иерархию классов, а также систему слотов для оружия у игрока.

### Процесс реализации

1. Создадим класс игрока и функцию main.

* Класс Player содержит список оружия и метод "_выстрелить_"
```java 
class Player {
    // Указываем тип данных Weapon, который будет храниться в "слотах игрока" 
    private List<Weapon> weaponSlots;
    
    public Player() {
        // Снаряжаем нашего игрока
        weaponSlots = Arrays.asList(
            // TODO заполнить слоты оружием
            // new BigGun(),
            // new WaterPistol()
        );
    }
    
    public int getSlotsCount() {
        // size - позволяет узнать сколько всего слотов с оружием у игрока
        return weaponSlots.size();
    }
    
    public void shotWithWeapon(int slot) {
        // TODO проверить на выход за границы
        // выбросить IllegalArgumentException,
        // если значение slot некорректно
        
        // Получаем оружие из выбранного слота
        Weapon weapon = weaponSlots.get(slot);
        // Огонь!
        weapon.shot();
    }
}
```

* Функция `main`
```java
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
        Player player = new Player();
        // Как настоящие программисты мы имеем ввиду что исчисление начинается с 0
        System.out.format("У игрока %d слотов с оружием,"
            + " введите номер чтобы выстрелить,"
            + " -1 чтобы выйти%n", 
            player.getSlotsCount()
        );
        int slot;
        
        // TODO главный цикл игры: 
        // запрашивать номер с клвиатуры 
        // с помощью scanner.nextInt(),
        // пока не будет введено -1
        
        System.out.println("Game over!");
}
```

2. Создадим классы для некоторых видов оружия.
* Базовый класс для всех видов оружия
```java
class Weapon {
    public void shot() {
        // TODO override me!
    }
}
```

> Как "заставить" дочерний класс переопределить поведение некоторых методов базового класса мы узнаем на следующей лекции.

* Создадим дочерние классы:
    * Пистолет
    * Автомат
    * РПГ
    * Рогатка
    * Водный пистолет

* В каждом из дочерних классов переопределите метод `shot()` чтобы он изменил поведение оружия в соответствии с его типом. Например, чтобы оно выводило в консоль соответствующие выстрелу звуки: `Пив-Пав!`.

3. Теперь можно вернуться к классу `Player` и создать по экземпляру каждого оружия.

## Задача № 2

Следующая задача пришла от наших бухгалтеров.

Бухгалтерская программа должна уметь проводить операции c различными агентами, как физическими/юридическими, так и с иностранными компаниями: чп, ип, ооо, зао, ~~иклмн~~, ~~ёпрст~~. С некоторых операций налог платить не нужно, некоторые облагаются подоходным налогом, с некоторых необходимо уплатить НДС. Необходимо расширить функциональность класса `Bill` возможностью работы с различными системами налогообложения.

### Процесс реализации

**Очень важное замечание!**

Практически в любом языке программирования, если вы вы напишите нечто подобное, вы получите не то что вы могли ожидать: 
```java 
System.out.println(0.1 + 0.2); // => 0.30000000000000004
```
Связанно это с тем, что числа в компьютере храняться в двоичном виде, и **конечные** дроби в десятичной системе счисления `0.1` и `0.2` превращаются в **бесконечные периодические** дроби в двоичной системе счисления `0.00011001100110011010` и `0.00110011001100110011` соответственно. Как следствие часть числа теряется, а значит и точность при операциях с ними. 
Подробнее про представление вещественных чисел в компьютере [на сайте ИТМО](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB).

Для того чтобы производить расчёты с десятичными дробными числами, существует специальный класс `BigDecimal` (большое десятичное). Большое, потому что у него нет стандартных ограничений как у `double (-1.7E+308 до 1.7E+308)` или `int (-2147483648 до 2147483647)`, он может хранить число состоящие из 2,147,483,647 цифр, ~~Карл~~! А десятичное, потому что каждая цифра числа хранится по отдельности, из-за чего не возникаем проблем с потерями при переводе между системами счисления.

В задаче предлагается принять некоторые неточности и использовать уже знакомый нам тип double. Плюсиком будет решение задачи `№ 2*` (со звёздочкой).

1. Класс `Bill`

В системе уже есть класс `Bill`, в который мы добавили поле `TaxType taxType;` и метод `payTaxes()`:

```java
class Bill {
    private double amount;
    private TaxType taxType;
    private TaxService taxService;
    
    public Bill(double amount, TaxType taxType, TaxService taxService) {
        this.amount = amount;
        this.taxType = taxType;
        this.taxService = taxService;
    }
    
    public void payTaxes() {
        // TODO вместо 0.0 посчитать размер налога исходя из TaxType
        double taxAmount = 0.0;
        
        taxService.payOut(taxAmount);
    }
}
```

А также класс налоговой службы:
```java
class TaxService {
    public void payOut(double taxAmount) {
        System.out.format("Уплачен налог в размере %.2f%n", taxAmount);
    }
}
```

2. Создадим классы для различных типов налогообложения.
* Базовый класс
```java 
class TaxType {
    public double calculateTaxFor(double amount) {
        // TODO override me!
        return 0.0;
    }
}
```
Классы расширяющие `TaxType`
* Подоходный налог, = 13% (`IncomeTaxType`)
* НДС, = 18% (`VATaxType`)
* Прогрессивный налог, до 100 тысяч = 10%, больше 100 тысяч = 15% (`ProgressiveTaxType`)

3. В методе `main` создадим несколько счетов и оплатим с них налоги в налоговую службу.

```java
public static void main(String[] args) {
    TaxService taxService = new TaxService();
    List<Bill> payments = Arrays.asList(
        // TODO создать платежи с различным типами налогообложения
    );
    for (int i = 0; i < payments.size(); ++i) {
        Bill bill = payments.get(i);
        bill.payTaxes();
    }
}
```

## Задача № 2* 

Реализовать тот же функционал, но используя вместо double –> BigDecimal.

Работа с ним может показаться необычной и странной, например их нельзя сложить используя оператор `+` (в java запрещено перегружать операторы) или сравнить с помощью `==` (так как это объект, произойдёт сравнение ссылок, а не значений объектов). Вместо этого мы должны использовать методы `.add(…)` и `.compareTo(…)` соответственно.
Экземпляр этого класса можно создать с помощью `new BigDecimal("0.1")` или `BigDecimal.valueOf(0.2)`.
Как и `String` экземпляры этого класса неизменяемые (иммутабельны), а методы `.add(…)`, `.multiply(…)` возвращают новый объект содержащий результат операции.
Например, чтобы сложить 0.1 рубля и 0.2 рубля и получить ожидаемые 30 копеек мы могли бы написать код:

```java
BigDecimal first = new BigDecimal("0.10");
BigDecimal second = BigDecimal.valueOf(0.2);

BigDecimal sum = first.add(second);

System.out.println(sum.toString()); // => 0.30
```

При делении BigDecimal нужно объязательно указывать способ округления результата. Про способы округления чисел в `BigDecimal` можно почитать [например тут](http://developer.alexanderklimov.ru/android/java/bigdecimal.php).

## Задача № 3

Крайняя задача на сегодня это музыкальный редактор. Мы хотим сделать редактор легко расширяемым и дать пользователю возможность подключать плагины с различными музыкальными инструментами.

Задача разработать систему классов `Track`, `Instrument` и `Song`.
`Track` состоит массива временных отметок и звучащего в этот момент инструмента. `Song` состоит из нескольких `Track`'ов.

> Задача не претендует на точность использования музыкальных терминов и обозначений. Предложения по улучшению от людей разбирающихся в теме приветствуются!

Сделать представление на экране в виде горизонтальной полосы треков (примерно как в [FL Studio](https://www.logic-templates.com/wp-content/uploads/2016/03/Shine-FL-Studio-Pro-Template.png)).
Чтобы получилось например так: 
```
---♫--♫--♫----♫--♫--♫
♪-♪-♪-♪-♪------♪-♪-♪-
------♫-♫--♫--♫--♫---
```

### Процесс реализации

1. Создать базовый класс `Instrument` содержащим метод `printNote()` и печатающим символ `-` в System.out.

2. Создать классы расширяющие `Instrument` для нескольких музыкальных инструментов.

3. Создать классы `Track` и `Song`, содержащие инструмент для каждой секунды и список треков соответственно. В обоих классах реализовать метод `print` печатающий содержимое на экран.

3. В функции `main` с помощью циклов создать несколько треков одинаковой длинны, поместить их в `Song`. Вывести песню на экран.

Пример создания `Track`:
```java
int SONG_LENGHT = 10;

List<Instrument> timeline = new ArrayList(SONG_LENGHT);

for (int i=0; i<SONG_LENGHT; ++i) {
    Instrument instrument;
    if (i % 4 == 0) {
        instrument = new Piano();
    } else if (i % 2 == 0) {
        instrument = new Klaxon();
    } else {
        instrument = new Instrument();
    }
    timeline.add(instrument);
}
```

## Инструкция по выполнению домашнего задания

1. Зарегистрируйтесь на сайте [Repl.IT](http://repl.it/).
2. Перейдите в раздел **my repls**.
3. Нажмите кнопку **Start coding now!**, если приступаете впервые, или **New Repl**, если у вас уже есть работы.
4. В списке языков выберите `Java`.
5. Код пишите в левой части окна, вместо строки `System.out.println("Hello world!");`.
6. Опирайтесь на принятый [стиль оформления кода](https://github.com/netology-code/codestyle/blob/master/java/README.md).
7. Посмотреть результат выполнения файла можно, нажав на кнопку **Run**. Результат появится в правой части окна.
8. После окончания работы нажмите кнопку **Share** и скопируйте ссылку из поля Share link.
9. В личном кабинете на сайте [netology.ru](http://netology.ru/) в поле комментария к домашней работе вставьте скопированную ссылку и отправьте работу на проверку.

*Никаких файлов прикреплять не нужно.*

Все задачи обязательны к выполнению для получения зачета. Присылать на проверку можно каждую задачу по отдельности или все задачи вместе. Во время проверки по частям ваша домашняя работа будет со статусом "На доработке".

Любые вопросы по решению задач задавайте в группе на Facebook.
